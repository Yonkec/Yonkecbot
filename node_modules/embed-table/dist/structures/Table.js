"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Table = void 0;
const Row_js_1 = require("./Row.js");
class Table {
    /**
     * Create a new Table
     * @param {TableData} options
     */
    constructor(options) {
        this.titleString = '';
        this.titles = options.titles;
        this.titleIndexes = options.titleIndexes;
        this.rows = [];
        this.columnIndexes = options.columnIndexes;
        this.start = options.start ?? '';
        this.end = options.end ?? '';
        this.padEnd = options.padEnd ?? 0;
        this.whiteSpace = options.whiteSpace ?? false;
        if (this.titles.length !== this.titleIndexes.length) {
            throw new RangeError('The \'titles\' and \'titleIndex\' array must be of the same length.');
        }
        for (let i = 0; i < this.titles.length; i++) {
            this.titleString += this.padTitle(i);
        }
    }
    /**
     * Add a row with data to the Table
     * @param {string[]} columns
     * @param {RowOptionData} options
     * @returns {this}
     */
    addRow(columns, options) {
        this.rows.push((options?.url ? '[' : '') +
            this.start + new Row_js_1.Row({
            columns,
            indexes: this.columnIndexes,
            whiteSpace: this.whiteSpace
        })
            .toString()
            .padEnd(this.columnIndexes[this.columnIndexes.length - 1] + (options?.override ?? 0 + this.padEnd), ' ') + this.end + (options?.url ? `](${options?.url})` : ''));
        return this;
    }
    /**
     * Convert the Table to an EmbedField object
     * @param {TableToFieldOptions} options Whether or not the field is inline
     * @returns {EmbedField} Use this when creating a MessageEmbed
     */
    toField(options) {
        const field = {
            name: this.titleString,
            value: this.rows.join('\n'),
            inline: options?.inline ?? false
        };
        if (!options?.keepRows)
            this.clear();
        return field;
    }
    /**
     * Convert the Table to a nice string
     * @param {TableToStringOptions} options
     * @returns
     */
    toString(options) {
        const string = this.titleString + '\n' + this.rows.join('\n');
        if (!options?.keepRows)
            this.clear();
        return string;
    }
    /**
     * Clear the rows out of the Table
     * @returns {void}
     */
    clear() {
        this.rows.length = 0;
    }
    /**
     * Adds the spacing to the titles in the title string
     * @param {number} i
     * @returns {string} The padded title
     */
    padTitle(i) {
        if (!this.checkTitles()) {
            throw new RangeError('Length of a \'title\' cannot be longer than the starting index of the next title. Try increasing the value of the subsequent \'titleIndex\'.');
        }
        return ' '.repeat(this.titleIndexes[i] - (this.titleIndexes[i - 1] ?? 0) - (this.titles[i - 1]?.length ?? 0)) + this.titles[i].slice(0, (this.titleIndexes[i + 1] ?? Infinity) - this.titleIndexes[i] - 1);
    }
    /**
     * Checks if the title texts are greater than the indexes provided
     * Returns true if less than, false if greater than.
     * @returns {boolean}
     */
    checkTitles() {
        for (let i = 0; i < this.titles.length - 1; i++) {
            if (this.titles[i].length > this.titleIndexes[i + 1])
                return false;
        }
        return true;
    }
}
exports.Table = Table;
//# sourceMappingURL=Table.js.map